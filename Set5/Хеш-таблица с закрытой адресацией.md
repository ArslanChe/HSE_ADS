Вам предстоит реализовать класс хеш-таблицы, который поддерживает хранение объектов, заданных парами (Ключ, Значение). Хеширование объектов выполняется по полю Ключ, то есть при вставке объекта в хеш-таблицу вычисляется значение используемой хеш-функции от поля Ключ. Разрешение коллизий выполняется с помощью метода цепочек.

Создаваемый шаблонный класс HashTable параметризуется:

Типом используемых ключей KeyType
Типом значения ValueType
Типом используемого хешера Func. По умолчанию используется функциональный объект стандартной библиотеки std::hash<KeyType>.
В случае если таблица заполнена более, чем на некоторое отсечное значение (коэффициент заполненности), выполняется перехеширование: удвоение емкости таблицы и перенос текущих объектов в новую таблицу. Коэффициент заполненности рассчитывается как отношение количества записей в хеш-таблице к количеству всех ячеек хеш-таблицы.

Скажем пару слов про «хешер». Это некоторый тип, который по ключу типа KeyType умеет выдавать значение типа size_t, которое можно получить, используя функциональный вызов.

Например:
// пусть hasher имеет тип Func
KeyType key = ...; // какой-то ключ
size_t num = hasher(key);

Благодаря использованию шаблонов, тип Func может быть чем угодно — функцией, лямбдой или же классом, для которого перегружен оператор вызова (). Это позволяет пользователю вашего класса выбирать наиболее предпочтительный для него вариант хеш-функции. Если же пользователя устраивает стандартный вариант, то используется стандартный тип std::hash<KeyType>.

Обратите внимание, что сам по себе хешер всего лишь дает вам возможность получить для любого объекта некоторое число (и предоставляется пользователем класса, поскольку вы заранее не знаете, с какими типами будет использоваться ваша таблица), а вот как его использовать для организации быстрой хеш-таблицы — уже ваша забота. Однако же если хешер, например, возвращает для всех ключей число
0
0, то ясно, что это проблема пользователя, а от вас мало что зависит (тем не менее, ваш класс должен по-прежнему корректно работать в таких ситуациях, это должно отражаться только на времени работы). Поэтому вы можете считать, что хешер распределяет ключи по диапазону size_t достаточно равномерно (в предположении, что ключи случайны) — в частности, это верно для варианта по умолчанию: std::hash<KeyType>.

Ваш класс должен содержать следующие конструкторы и методы:

Конструктор по умолчанию. Размер таблицы по умолчанию принимается равным 100. Коэффициент наполненности по умолчанию принимается равным 0.5.
Конструктор с одним параметром - типом используемой хеш-функции.
Конструктор, который позволяет задавать максимальный размер таблицы и коэффициент наполненности, а также тип используемой хеш-функции. Последний параметр - тип используемой функции - может быть опущен. Коэффициент наполненности принимает значения от
0
0 до
1
1, где
1
1 включительно, а
0
0 нет. В случае передачи в конструктор неверного значения коэффициента наполненности, следует принять его равным дефолтному значению - 0.5.
Деструктор!
Константный метод size, возвращающий количество элементов в таблице.
Константный метод capacity, возвращающий текущее значение емкости таблицы.
Метод insert, который вставляет пару (ключ, значение) в хеш-таблицу. Принимает на вход два параметра (ключ, значение), вычисляет значение хеш-функции от поля Ключ (с поправкой на размер таблицы) и добавляет запись об этом объекте в таблицу. В случае коллизии, объект добавляется в конец соответствующей хешу цепочки. В случае, если объект с таким полем ключ уже имеется, то происходит обновление поля Значение. При превышении коэффициента наполненности (size / capacity > coeff) происходит перехеширование. Тип возвращаемого значения void.
Метод erase, который принимает ключ и удаляет соответствующую пару (ключ, значение) из таблицы. В случае, если запись с таким ключом не найдена, то метод ничего не меняет.
Метод find, возвращающий указатель на значение, соответствующее переданному ключу хеш-таблицы, если ключ в ней присутствует, и nullptr в противном случае.
Оператор индексации (operator []), который возвращает ссылку на запись хеш-таблицы по значению переданного хеш-кода (односвязный список элементов) по ссылке. Если переданный хеш-код находится вне таблицы, то генерируется исключение std::out_of_range. Если переданный хеш-код указывает на пустую ячейку, то генерируется исключение std::runtime_error.
Метод at, который возвращает запись хеш-таблицы по значению переданного хеш-кода (односвязный список элементов) по значению. Если переданный хеш-код находится вне таблицы, то генерируется исключение std::out_of_range. Если переданный хеш-код указывает на пустую ячейку, то генерируется исключение std::runtime_error.
Ваш класс должен состоять из (Node) узлов (тип элементов параметризуется - KeyType, ValueType) - односвязный список, содержащий объекты с одним хеш-кодом.

Структура Node должна содержать следующее:

Поле key – хранит ключ текущего узла (тип элемента - KeyType).
Поле value – хранит значение текущего узла (тип элемента - ValueType).
Поле next – хранит указатель на следующий узел с тем же хеш-кодом (поддерево).
Конструктор, принимающий на вход два значения: key (тип - KeyType), value (тип - ValueType)